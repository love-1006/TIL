## Section 01 키 배송 문제

### 1. 키 배송 문제란?

**`키 배송 문제**(key distribution problem)`

- 대칭 암호를 사용하려면 송신자와 수신자가 대칭키를 사전에 공유해야 하는 문제
- 대칭 키를 보내지 않으면 밥은 복호화할 수 없다

### 2. 키의 사전 공유에 의한 키 배송 문제의 해결

- 안전한 방법으로 키를 사전에 건네주는 것
- 직접전달은 안전하지만 이메일/일반메일 등은 위험하다.
- 인원이 많아지면 관리 해야 할 키 수 증가

### 3. 키 배포 센터에 의한 키 배송 문제의 해결

키 배포 센터에 의한 해결 `(key distribution center; KDC)`

- 암호 통신 때마다 통신용 키를 키 배포 센터에 의뢰해서 개인과 키 배포 센터 사이에서만 키를 사전에 공유
키 배포 센터의 역할을 하는 컴퓨터를 지정
구성원 전원의 키를 보존
- 구성원 수 증가 시 키 배포 센터의 부하
키 배포 센터의 컴퓨터가 고장 시 조직 전체의 암호 통신 마비
키 배포센터가 공격의 대상이 될 수 있다.
사회공학적공격방법

### 4. **Diffie-Hellman 키 교환에 의한 키 배송 문제의 해결**

- 암호 통신을 원하는 두 사람이 있다면 어떤 정보를 교환한다. (이 정보는 도청자 이브에게 노출 되어도 무방)
- 두 사람은 교환한 정보를 가지고 동일한 키를 각각 생성할 수 있다. (도청자 이브는 같은 키를 만들 수 없다.)

### 5. 공개키 암호에 의한 키 배송 문제의 해결

- 대칭 암호
    - 「암호화 키」와 「복호화 키」 동일
- 공개 키 암호
    - 「암호화의 키」와 「복호화 키」가 다르다.
    - 두 키는 한쌍이며 수학적관계가 있다.
    - 「암호화 키(공개 키)」를 가지고 있는 사람이라면 누구든지 암호화 할 수 있음
    - 하지만 「암호화 키」를 가지고 있어도 복호화할 수 X, 복호화할 수 있는 것은 「복호화 키」를 가지고 있는 사람 뿐
    - 수신자는 미리 「암호화 키」를 송신자에게 알려 준다. (이 「암호화 키」는 도청자에게 알려져도 무방)
    송신자는 그 「암호화 키」로 암호화해서 수신자에게 전송
    - 암호문을 복호화할 수 있는 자는 「복호화 키」를 가지고 있는 사람(수신자)뿐
    「복호화 키」를 수신자에게 배송할 필요가 없음
    

---

## Section 02 공개 키 암호

### 1. 공개 키 암호란?

**`공개 키 암호**(public-key cryptography)`

「암호화 키」와 「복호화 키」가 분리

송신자는 「암호화 키」를 써서 메시지를 암호화하고, 수신자는 「복호화 키」를 써서 암호문을 복호화

**공개키와 개인키**

**`공개 키(public key)` :** 「암호화 키」는 세상 모든 사람들에게 공개해도 무방 → 이브에게 공개키과 도청되는 것을 신경 쓸 필요가 없다.

**`개인 키(private key)` :** 「복호화 키」는 미공개로 본인만 사용 → 개인 키는 다른 사람에게 보이거나, 건네주거나 해서는 안 됨 (자신의 통신 상대에게도 보여서는 안된다.)

**`키 쌍(key pair)` :** 공개 키와 개인 키는 둘이 한 쌍

- 공개 키로 암호화한 암호문은 그 공개 키와 쌍이 되는 개인 키가 아니면 복호화 할 수 없다.
- 두 키는 수학적인 관계를 가진 밀접한 관계다.
- 키 쌍은 별개로 만들 수 없다.

**공개키 암호의 역사**

Ron Rivest, Adi Shamir, Leonard Adleman(1978)

현재는 RSA암호를 사용하고있다.

### 2. 공개키를 사용한 통신의 흐름

앨리스가 밥에게 메시지 보내기

(1) 밥은 공개 키/개인 키로 이루어진 한 쌍의 키 생성

(2) 밥은 자신의 공개 키를 앨리스에게 전송

(3) 앨리스는 밥의 공개 키를 써서 메시지를 암호화

(4) 앨리스는 암호문을 밥에게 전송

(5) 밥은 자신의 개인 키를 써서 암호문을 복호화

### 3. 여러가지 용어

**대칭 암호**(symmetric cryptography)

- 동일키 사용해서 암호화와 복호화 수행
- 키 : 비밀키(secret key)라고 함

**비대칭 암호**(asymmetric cryptography)

- 암호화와 복호화에 다른 키 사용
- 키 : 개인키(private key)와 공개키(public key)

### 4. 공개키 암호로도 해결할 수 없는 문제

**공개 키의 인증**에 관한 문제

- 입수한 공개 키의 진위를 판단할 필요
- 중간자공격(man-in-the-middle attack)

**공개 키 암호의 속도**

- 대칭 암호에 비해 처리 속도가 몇 백 배나 늦음

---

## Section 03 시계 연산

**`mod` :** 「**나눗셈을 해서 나머지를 구하는 계산**」을 위한 기호 (연산자)

ex) 27 mod 12 = 27을 12로 나눈 나머지(27 모드 12) = 3

→ 「27과 3은 12를 제수로 해서 **합동**이다」라고 표현

### 1. 덧셈

(7 + 6) mod 12  = ?

13 mod 12 = 1

### 2. 뺄셈

(7 + □) mod 12 = 0,  □ = ?

□ = 5 이다

→ 5가 -7의 역할을 한다

### 3. 곱셈

7 × 4 mod 12 = 28 mod 12 = 4

### 4. 나눗셈

7 × □ mod 12 = 1,  □ = ?

→ 전사공격으로 해결,  □ = 7

**역수계산**

- mod 12의 세계에서 역수를 갖는 수는 12와 그 수가 1이외의 공통의 약수를 갖지 않는 수이다.
- 12와의 최대공약수가 1인 수(5, 7, 11)는 수학에서는 12와 **서로** **소**라고 한다

### 5. 거듭제곱

$7^{4}$ mod 12 = ?

1. 7 × 7 × 7 × 7 mod 12
= 2401 mod 12
2. 계산의 도중에 mod을 취해도 같은 결과
    
    7 × 7 × 7 × 7 mod 12
    = [(7 × 7 mod 12) × (7 × 7 mod 12)] mod12
    = [(49 mod 12) × (49 mod 12) ] mod 12
    = [(1 mod 12) × (1 mod 12)]mod 12
    = 1 × 1 mod 12
    = 1 mod 12
    

### 6. 대수

거듭제곱의 역 연산

$7^{X}$ mod 13 = 8와 같은 문제는 사용되는 숫자가 매우 크면 이산 대수 계산이 매우 어렵고 시간이 대단히 많이 걸린다.

---

**참고: 디피-헬만-머클 열쇠교환 Scheme**   

$Y^{x}$ mod(N) 공개된 알고리즘: 일방향함수

- 곱하기는 쉽지만 나누는 것은 어려움 (N이 커질수록 더욱 힘들다.)

| Step | Allice | Bob |
| --- | --- | --- |
| 1 | 자기만 아는 비밀의 수 A를 하나 선택 
i.e. A=3 | 자기만 아는 비밀의 수 B를 하나 선택 
i.e. B=6 |
| 2 | Allice의 일방향함수
$7^{3}$(mod 11) = 2         (α=2) | Bob의 일방향함수
$7^{6}$(mod 11) = 4         (β=4) |
| 3 | 값 2를 Bob에게 전달 | 값 4를 Allice에게 전달 |
| 교환 | Eve는 도청을 통해 α, β 를 획득 (2, 4), 그러나 (A, B)값은 모름 | Eve는 도청을 통해 α, β 를 획득 (2, 4), 그러나 (A, B)값은 모름 |
| 4 | $β^{A}$ (mod11) 
$4^{3}$ (mod11) = 9 | $α^{B}$ (mod11) 
$2^{6}$ (mod11) = 9 |
| KEY | KEY = 9 | KEY = 9 |

같은 키를 갖게된다!

11가 아닌 엄청나게 큰 수라면? 답을 구하기 정말 어려워짐

N = 서로 소인수 관계인 p,q 둘의 곱

### 7. 시계바늘에서 RSA로

평문을 공개키로 암호화하면 암호문

암호문을 공개키로 복호화하면 평문

---

## Section 04 RSA

### 1. **RSA란 무엇인가?**

**RSA**는 공개 키 암호 알고리즘의 하나

**R**on Rivest, Adi **S**hamir, Leonard **A**dleman의 이니셜

- 공개 키 암호, 디지털 서명, 키 교환 등에 사용

### 2. **RSA에** **의한 암호화**

RSA에서 평문도 키도 암호문도 숫자로 변환한 뒤 실행

- RSA의 암호화
    
    $암호문 = (평문)^E\mod N$
    
    - E, N은 한쌍의 공개 키, 이 수를 알면 누구라도 암호화를 행할 수 있다.
    - E와 N이 RSA 암호화에 사용되는 키
    - E와 N은 면밀한 계산을 통해 생성
- RSA의 복호화
    
    $평문 = (암호문)^E\mod N$
    

E에서 N을 계산해내는 과정이 어려운 점을 활용한다.

**N = 서로 소인수 관계인 p,q 둘의 곱**

<img width="574" alt="Untitled" src="https://github.com/love-1006/TIL/assets/163835194/e136809d-059a-4326-8c65-75cd0b62d563">

---

## Section 05 RSA에 대한 공격

- 암호 해독자가 알고 있는 것
    - 암호문 : 도청해서 구한다
    - E와 N : 공개 키로서 공개
- 암호 해독자가 모르는 것
    - 평문 : 지금부터 해독하려고 하는 내용
    - D : 개인 키 중 적어도 D는 모름
    - 기타 : 키 쌍을 만든 p, q(N의 소수), L을 모름
    

### 1. 암호문으로부터 평문 구하기

$암호문 = (평문)^E\ mod\ N$

에서 평문을 구하려면 이산 대수 문제를 풀어야 하지만, 현재까지 아직 이산 대수를 구하는 빠른 방법을 알지 못함

### 2. 전사 공격

- D의 후보가 되는 수를 순서대로 모두 시도해서 복호화 해본다
→ D의 비트 수가 크면 클수록 어려워진다
- 비트 수가 충분히 크면 전사공격으로 수 D를 찾아내는 것은 현실적으로는 불가능
→ RSA에서는 p와 q의 비트 수로서 512 비트 이상을 사용
→ N은 1024 비트 이상을 이용
→ E나 D는 N과 같은 정도의 크기로 할 수 있으므로 D를 찾으려면 1024 비트 이상의 전사공격이 필요하다.
→ 현실적으로 불가능  $2^{1024}$

### 3. E와 N으로부터 D구하기

$E × D \mod L = 1$

- L은 lcm(p-1, q-1)이므로 E로부터 D를 계산할 때는 p와 q를 사용
- 암호해독자는 p와 q를 전혀 모름
- 해독자는 D를 구할 수 없음
- RSA의 안전성을 위해 소수 p와 q를 암호 해독자가 모르게 해야 함

**N의 소인수 분해**

- N = p × q라는 관계식을 공격자는 알고 있고, N은 공개되어 있다.
- N으로 부터 p와 q를 구할 수 없는 것일까?
- p와 q는 소수이기 때문에 N으로부터 p와 q를 구한다는 것은 자연수 N을 소인수분해하는 것

**p와 q 추측하기**

- 소인수분해를 하지 않아도 p와 q가 암호 해독자에게 알려질 가능성은 있다.
- p와 q는 의사난수 생성기도 생성하기 때문에 의사난수 생성기의 품질이 나쁘면 p와 q를 암호 해독자가 추측할 수 있다.
- 난수 생성기가 강력해서 암호 해독자가 추측할 수 없어야 한다.

**기타 공격**

- N을 소인수분해 해서 p와 q를 구할수 있으면 D를 구할 수 있다.
- "D를 구하는 것"이 "N을 소인수분해 하는 것"과 수학적 같은지 아닌지가 증명되어 있지 않다.
- N을 소인수분해 하지 않아도(p와 q를 몰라도) E와 N으로 부터 D를 구하는 방법이 있을 수 있다.

### 4. 중간자 공격

**`중간자(man-in-the-middle) 공격**`   

RSA를 해독하는 게 아닌 기밀성을 침해하는 공격

공격자 맬로리가 송신자와 수신자 사이에서 송신자에 대해서는 수신자 처럼, 수신자에 대해서는 송신자처럼 행세하는 공격

<img width="460" alt="Untitled2" src="https://github.com/love-1006/TIL/assets/163835194/e899ae67-6b6a-4e73-8cbf-39f687ead148">

---

## Section 06 선택 암호문 공격

**암호 공격자 모델**

암호문 단독 공격(Ciphertext-Only Attack)

알려진 평문 공격(Known-Plaintext Attack)

선택 평문 공격(Chosen-Plaintext Attack)

선택 암호문 공격(Chosen-Ciphertext Attack)

### 1. **복호 오라클(Decryption Oracle)**

**임의의 데이터를 송신하면 그것을 암호문으로 간주하고 회신 해주는 서비스**

### **2. 선택암호문 공격(Chosen Ciphertext Attack)**

**복호 오라클 공격을 공격자가 이용할 수 있다고 가정한 공격**

**공격대상인 암호문은 제외**

**복호 오라클 서비스의 의미**

- 넌센스처럼 보이지만 실제 네트워크에서 오류메시지 반환을 악용하는 공격이다.
- 위조 암호문을 여러 차례 전송하여 반환된 오류 메시지나 타이밍 정보를 활용해 평문을 추측
- RSA의 경우 선택암호문 공격으로 약간의 정보 취득 가능

---

## Section 07 기타 공개 키 암호

### 1. **ElGamal** **방식**

**ElGamal** **방식**은 Taher ElGamal에 의한 공개 키 알고리즘 (RSA와 비슷하다.)

- RSA는 소인수분해의 어려움을 이용
- 암호화에서는 암호문의 길이가 평문의 2배가 되어 버린다는 결점
- GnuPG에서 사용

### 2. **Rabin 방식**

**Rabin 방식**은 M. O. Rabin에 의한 공개 키 알고리즘

- Rabin 방식은 mod N으로 평방근(루트)을 구하는 것이 어렵다는 사실을 이용
- 공개 키 암호의 해독은 소인수분해 정도로 어렵다는 것이 증명

### 3. **타원곡선 암호**

**타원 곡선 암호**(elliptic curve cryptosystems; ECC)는 최근 주목받고 있는 공개 키 암호 알고리즘

- RSA에 비해 키의 비트 수가 적게해도 보안성을 유지 가능하다. → 좀 더 심플하고 가벼운 암호를 고안함.
- 타원 곡선 위에 곱셈을 정의하고, 이 곱셈의 역연산이 어렵다는 것을 이용

대칭키 암호화 공개키 키교환에 사용

---

## Section 08 공개 키 암호에 관한 Q&A

### 1. 공개 키 암호의 기밀성

- Q : 공개 키 암호는 대칭 암호보다도 기밀성이 높은가?
- A : 이것만으로는 답할 수 없다. 왜냐 하면 키의 비트 길이에 따라 기밀성의 정도는 변화하기 때문

→ 둘은 용도도, 알고리즘도 다르다.

→ 대칭키는 암호화에 공개키 키교환에 사용된다.

### 2. 공개 키 암호와 대칭 암호의 키 길이

- Q : 1024비트 길이의 키를 갖는 공개 키 암호와, 128비트 길이의 키를 갖는 대칭 암호에서는 비트 길이가 긴 공개 키 암호 쪽이 안전한가?
- A : 아니다.
    
    공개 키 암호의 키 길이와, 대칭 암호의 키 길이는 직접 비교할 수 없다.
    

### 3. 대칭 암호의 미래

- Q : 공개 키 암호가 생겼기 때문에 앞으로 대칭 암호는 사용할 필요가 없는가?
- A : 아니다.
    
    일반적으로 같은 정도의 기밀성을 갖는 키 길이의 경우, 공개 키 암호는 대칭 암호보다도 몇 백 배나 느리다
    
    공개 키 암호는 긴 메시지를 암호화하기에는 적합하지 않다
    
    목적에 따라 대칭 암호와 공개키 암호 두 가지 모두 사용
    

### 4. RSA와 소수

- Q : RSA의 키 쌍을 모두가 자꾸 만들어 가면 그 사이 소수가 없어져 버리는 것은 아닐까?
- A : 그럴 염려는 없다.
    
    512비트로 표현할 수 있는 소수의 수는 대략 10150으로 전 우주에 존재하는 원자의 개수보다도 많은 수이다
    

### 5. RSA와 소인수 분해

- Q : RSA를 해독하는 것은 큰 수를 소인수분해 하는 것과 같은 것인가?
- A : 같은 것인지 아닌지 아직 모른다.
    
    분명히 소인수분해를 고속으로 할 수 있다면 RSA는 해독된다
    
    RSA를 해독하려면 소인수분해를 꼭 해야 한다는 것이 증명된 것은 아님
    
    어쩌면 소인수분해를 하지 않아도 해독할 수 있는 방법이 발견될지도 모름
    

### 6. RSA의 비트길이

- Q : 소인수분해 되지 않기 위해서 N은 몇 비트 길이가 필요한가?
- A : 아무리 비트 수가 커도 언젠가는 소인수분해 된다
