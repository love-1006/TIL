# CHAPTER 03 암호의 역사

---

## Section 01 시저 암호

### 1. 시저 암호란?

`시저 암호(Caesar cipher)`

- 줄리어스 시저(유리우스 케사르)가 사용하였다는 암호
- 평문으로 사용되는 알파벳을 일정한 문자 수 만큼 평행이동 시킴으로써 암호화 (`전치암호`)

### 2. 시저 암호의 암호화

<img width="648" alt="Untitled 1" src="https://github.com/love-1006/TIL/assets/163835194/ce0203d6-eeaa-4b31-bb9d-b16883f1e4e1">

![Untitled 2](https://github.com/love-1006/TIL/assets/163835194/fb732ab2-6e8e-4094-a7a5-51d9ab1511c8)

[알파벳 문자를 평행이동 시킨다] → 암호알고리즘

[평행 이동시키는 문자수] → 키

### 3. 시저 암호의 복호화

암호와때와 동일한 크기의 역방향 평행이동

### 4. 전사 공격에 의한 해독

암호문 NDeVRRQBHH 을 보고 다른 정보 없이도 kabsoonyee 라는 메시지를 맞출 수는 없을까?

- 영어 알파벳은 26 문자이므로 암호화 키는 0에서 25까지 26가지 → 키스페이스의 개수는 26가지임
- 전사공격을 통해 복호화가 가능하다.
    - `전사공격(brute-force arrack)` : 키가 될 수 있는 모든 가능한 후보들을 시도해 보는 방법
    

---

## Section 02 단일 치환 암호

### 1. 단일 치환 암호란 무엇인가?

**`단일 치환 암호**(simple substitution cipher)` : 평문을 구성하는 알파벳을 다른 알파벳으로 변환하는 암호

- 시저 암호는 단일 치환 암호

### 2. 단일 치환 암호의 암호화

단일치환 암호는 알파벳 한 문자씩 치환표를 참조하여 변환해 가는 작업이다.

약점 : 평문에 등장하는 문자의 빈도가 암호문으로 바뀐 뒤에도 암호문 내에서 동일한 빈도로 나타난다.

### 3. 단일 치환 암호의 복호화

치환표 = 단일 치환 암호의 「키」

→ 복호화시, 암호화 때에 사용한 치환표가 필요

→ 송신자와 수신자는 치환표를 공유

### 4. 단일 치환 암호의 키 공간

단일치환 암호는 전사공격으로 해독이 어렵다.

시저암호에 비해 훨씬 많은 키 후보를 가질 수가 있기 때문이다.

- 시저암호의 `키공간`은 26개
- 단일치환 암호의 키공간은 26*25*24* … *2*1 (대략 4조의 1000조배)

 

`키 공간(key space)` : 해당 암호에서 사용할 수 있는 「모든 키의 집합」

- 이 키 공간에 속하는 가능한 키의 총수가 키 공간의 크기
- 키 공간이 크면 클수록 전사공격은 어렵다

### 5. 빈도 분석에 의한 해독

전사 공격에서 단일 치환 암호를 해독하는 것은 어려우나, **`빈도 분석`**암호 해석법을 사용하면 단일 치환 암호도 해독할 수 있다.

→ 영어알파벳의 사용빈도, 자주 등장하는 단어 점검(ex. The), 익숙한 단어 추측, 단어 패턴, 빈도추측, 빈도가 낮은 문자 추측, 단어와 내용 추측 등

- 빈도가 높은 문자뿐만 아니라 빈도가 낮은 문자도 단서
- 처음과 끝을 아는 것은 단서
- 단어의 단락을 알면 그것도 단서
- 암호문이 길면 해독이 용이
- 같은 문자가 연속해서 나타나면 그것은 단서(단일 치환 암호에서는 어떤 문자가 어느 문자로 암호화되는지 정해져 있기 때문)
- 해독의 속도가 점점 빨라짐
    - 키스페이스가 줄어들어 해독이 가능하게 된다.
    

---

## Section 03 다중 치환 암호

### **1. 빈도 분석이 가능한가?**

빈도분석이 가능했던 이유는 평문에 등장하는 문자의 빈도와 암호문에 등장하는 문자의 빈도가 일치하기 때문

**`다중치환암호**(polyalphabetic substitution cipher)`

- 평문에 등장하는 문자의 빈도와 암호문에 등장하는 문자의 빈도를 다르게 만드는 암호 알고리즘 → 빈도분석을 이용한 공격방법이 무용지물
- 비장느르 암호(Vigenere Cipher) : 1번째 행은 평문문자, 1번째 열은 키, 나머지는 암호문
- 에니그마 기계(Enigma machine)

---

## Section 04 에니그마

### 1. 에니그마란 무엇인가?

**`에니그마(enigma)` :** 독일의 세르비우스(Arthur Scherbius)가 20세기 초에 발명한 암호화/복호화를 수행하는 기계

- 에니그마는 독일어로 「수수께끼」를 의미
- 회전하는 원반과 전기회로를 써서 강력한 암호를 만들고자 시도
- 발명 당시에는 에니그마를 상용으로 사용하였으나, 나치독일 시대에는 군용으로 사용하려고 개량

![Untitled 3](https://github.com/love-1006/TIL/assets/163835194/38ac1b98-c131-4404-b390-fd9b2a30af49)
<img width="661" alt="Untitled 4" src="https://github.com/love-1006/TIL/assets/163835194/5a1d31a8-3ece-4a9f-a139-5fbf7effa991">


### 2. 에니그마에 의한 암호통신

타이프라이터와 톱니바퀴와 전지와 전구를 조합한 기계

암호화와 복호화를 1 대의 기계로 수행, 송신자와 수신자는 각각 에니그마를 1 대씩 소유

`코드북` : 송/수신자가 사용하는 날짜별키가 기록되어있으며, 이 지시에 따라 에니그마를 설정한다.

### 3. 에니그마의 구조

에니그마는 알파벳 26 문자를 암/복호화 할 수 있다. 

플러그보드(연결선이 코드북에 따른 날짜별 키로 정해짐), 로터 등

### 4. 에니그마의 암호화

평문: secretletter 를 암호화하여 송신하기

- 에니그마 설정
    - 코드북의 날짜별 키에 맞춘다.
- 통신키의 암호화
    - 송신자는 알파벳 3글자를 정해 암호화 한다.(이를 통신 키라함)
    - 통신 오류 회피를 위해 통신키를 2회 연속하여 입력한다. ex)abcabc
- 암호화된 통신키 메모
    - 문자를 칠때마다 로터가 돌아가며 해당 알파벳에 램프가 들어온다. 이를 메모한다.
- 에니그마의 재설정
    - 송신자는 통신 키에 따라 에니그마를 재설정한다.
- 메시지의 암호화
- 결합
    - 암호화된 통신키와 암호화된 메세지를 결합
    

### 5. 날자별 키와 통신 키

날짜별 키는 [키를 암호화 하기 위한 키]로 `키 암호 키(key encrypting key; KEK)`라 한다.

메시지를 통신키로 암호화하고, 통신키를 날짜별 키로 암호화하는 2단 구조

### 6. 통신 오류의 회피

통신키를 2회 연속해서 입력 →  당시 무선 기술수준이 낮아서 통신이 제대로 되지 않는 경우가 많이 있었기 때문

### 7. 에니그마의 복호화

<img width="639" alt="Untitled" src="https://github.com/love-1006/TIL/assets/163835194/d04249e5-4f4a-4445-a4e8-5d5c9de18e49">

### 8. 에니그마의 약점

통신키를 2회 반복한 것을 암호화 한다.

통신키를 선택한 것이 사람이다.

- 현대에는 난수를 이용해 키생성

코드북을 배송하지 않으면 안 된다.

### 9. 에니그마의 해독

숨기는 것에 의한 보안」(security by obscurity)에 의존하고 있지 않아 해독이 어려웠다. 이후에 영국의 암호팀에 의해 해독됨.

---

## Section 05 암호 알고리즘과 키

### 1. **암호 알고리즘과 키를 분리하는 이유**

암호화 알고리즘은 [암호알고리즘] + [키] 로 이루어져있다.

암호알고리즘은 반복해서 사용하지만 키는 매회 변경된다.

---

## Section 06 이 장의 정리

암호의 역사를 살펴보고자 시저암호, 단일치환암호, 에니그마를 살펴보았다.

암호해독의 예로 전사공격과 빈도분석을 살펴보았다.

다음 장 부터는 컴퓨터를 이용한 암호기술에 대해 살펴보자.
