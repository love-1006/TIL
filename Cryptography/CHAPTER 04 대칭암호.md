## Section 01 문자 암호에서 비트열 암호로

### 1. 부호화

암호화에 컴퓨터 사용은 필수적이다.

암호화 프로그램도 평문을 비트열로 변경하고 비트열로 된 암호문을 출력한다.

- `부호화(encoding)` ↔ 복호화(decoding) : 문자열을 비트열로 바꾸는 것
- `ASCII` : 비트열로 부호화하는 규칙

### 2. XOR (배타적 논리합)

- `익스클루시브 오아(exclusive or)` 또는 엑스오아
    
    0 XOR 0 = 0 (0과 0의 XOR은 0이 된다)
    0 XOR 1 = 1 (0과 1의 XOR은 1이 된다)
    1 XOR 0 = 1 (1과 0의 XOR은 1이 된다)
    1 XOR 1 = 0 (1과 1의 XOR은 0이 된다)
    
    - 같은 것 끼리 XOR하면 0, 다른 것 끼리 XOR하면 1이된다.
- 평문 A를 키 B로 암호화하고, 암호문 A ⊕ B를 얻는다.
- 암호문 A ⊕ B를, 키 B로 복호화해서 평문 A를 얻는다. → 두번 암호화하면 평문이 된다.
- 그림을 마스크한다.

<img width="530" alt="Untitled" src="https://github.com/love-1006/TIL/assets/163835194/692509a2-f509-44ab-9abf-4ad503826e7e">

---

## Section 02 일회용 패드 - 절대 해독 불가능한 암호

### 1. 일회용 패드란?

`one-time pad` : 전사공격에서 키 공간을 모두 탐색하더라도 해독할 수 없는 암호

### 2. 일회용 패드의 암호화

- **평문** : 아스키코드로 부호화
- **키** : 평문 길이와 같은 랜덤 비트열 준비 (XOR에 의한 암호화 키)

평문과 랜덤한 비트열과의 XOR만을 취하는 단순한 암호

데이터 길이와 같은 암호키(난수열) 활용

암호키는 한번만 사용한다 → 일회용

### 3. 일회용 패드의 복호화

암호문과 키의 XOR을 계산하면 평문

### 4. 일회용 패드는 해독할 수 없다

shannon은 일회용 패드를 해독할 수 없다는 사실을 수학적으로 증명했다.

**전사공격을 해도 해독 불가능** : 문자열이 복호화 되어도 그것이 바른 평문인지 아닌지 판정 할 수 없다.

- 복호화를 위해 모든 종류의 키를 대입하여 복호화시에 aaaaaaaa, gkeobndk, UeL([@ss 등 모든 종류의 패턴이 등장한다.
- 8글자일시, 8글자로 표현 할 수 있는 모든 단어들이 다 나온다.

### 5. 일회용 패드는 왜 사용되지 않은 것일까?

- **키 배송문제**
    - 키의 길이와 통신문의 길이가 같다.
    - 키를 안전하게 배송할 방법이 있다면 평문 자체를 안전하게 보낼 수 있었을 것이다.
- **키 보존**
    - 키의 길이와 통신문의 길이가 같다.
    - 키를 안전하게 보존할 방법이 있었다면 평문 자체를 안전하게 보관할 수 있었을 것이다.
- **키 재사용**
    - 과거에 사용한 랜덤한 비트열을 절대로 재사용하면 안된다. → 일회용인 이유
    - 이전 암호문을 보관하던 암호해독자가 있을시 모두 복호화된다.
- **키 동기화**
    - 통신하는 동안 송신자와 수신자 사이에 키가 되는 비트열이 1 비트라도 어긋나서는 안된다.
- **키 생성**
    - 난수를 대량으로 생성할 필요가 있다.
    - 의사난수(PRNG)가 아닌 재현성이 없는 실제 난수(RNG)
        - 난수 :  무작위성, 예측불가, 재현불가

→ 이러한 이유들로 일회용패드는 실제로는 거의 사용되지 않는다.

→ 후에 일회용패드의 아이디어는 스트림암호에 활용되고있다.

---

## Section 03 DES

- `DES(Data Encryption Standard)`는 1977년에 미국의 연방 정보처리 표준 규격(FIPS)으로 채택된 대칭 암호
- 최근에는 전사공격으로 해독할 수 있는 수준 → 과거에 DES암호문을 복호화하는 용도 외에 사용X

### 1. 암호화와  복호화

- DES는 평문을 64비트 암호문으로 암호화하는 대칭 암호 알고리즘
- 키의 비트길이는 56비트
    - 규격상으로는 64비트지만, 7비트마다 에러검출을 위한 정보가 1비트씩 들어감
- 키 스페이스 : $2^{56}$
- `블록암호 (block cipher)`
    - 블록 단위로 처리를 하는 암호 알고리즘
    - 긴 비트 길이의 평문을 암호화하기 위해서는 평문을 64비트 블록으로 나누고 각각을 DES로 암호화
- 16라운드, `페이스텔구조(Feistel network)`

shannon의 암호이론 : Confusion(혼돈)과 Diffusion(확산)

혼돈과 확산의 설질을 이용하여 안전한 블록 암호를 설계할 수 있다.

- 혼돈 : 평문과 암호문의 상관관계를 숨김 → S-Box
    - 평문 1비트의 변화가 암호문에 어떤 영향을 초래할 지 예측할 수 없어야 함
- 확산 : 평문을 구성하는 각각의 비트들의 정보가 여러 개의 암호문비트에 영향을 미쳐야 함 →  P-Box
- `혼합암호(Product Cipher)`: 각 블록마다 전치(P)와 대체(S) 암호의 2가지 방법을 모두 사용하는 암호화 방법
    - `페이스텔 구조 방식 암호알고리즘`
        1. 입력 N비트를 2개의 블록으로 나눈다.
        2. 입력을 좌우 블록으로 분할한다.
        3. 한 블록을 라운드 함수에 적용시킨 후 출력값을 다른 블록에 적용한다.
        - 암호화 강도 결정 요소 : 평문 블록의 길이, 키 길이, 라운드 수
            - 원하는 만큼 라운드수를 늘릴 수 있다.
        - 라운드 함수 F에 어떤 함수를 사용해도 복호화가 가능하다.
        - 암호화와 복호화 과정이 동일하여 라운드 함수와 관계없이 역변환 가능
            - 1라운드에서 오른쪽 반은 아무런 처리를 하지 않는 것은 복호화를 보증한다.
        - 알고리즘 수행 속도가 빠르다.
    - `S/P -Network구조`
    

**(1) DES의 암호화**

- **페이스텔 네트워크 1라운드**

<img width="683" alt="Untitled 1" src="https://github.com/love-1006/TIL/assets/163835194/f0366512-4017-4305-a477-60fc26da1f18">

- 라운드함수 F는 R과 서브키 k1을 사용하여 랜덤하게 보이는 비트열을 계산한다.
- 메인키는 56비트가 들어오지만 서브키는 48비트가 들어온다.

- **페이스텔 네트워크 3라운드**
    
    <img width="609" alt="Untitled 2" src="https://github.com/love-1006/TIL/assets/163835194/964de00d-65ab-4907-be46-138fcf890699">


이런 식으로 16번 반복된다.

**(2) DES의 복호화**

<img width="609" alt="Untitled 3" src="https://github.com/love-1006/TIL/assets/163835194/508c823c-b59a-49ab-bfed-4315b5f69739">

암호화와 복호화가 완전히 동일한 구조로 실현된다.

### 2. 차분 해독법과 선형 해독법

블록암호 해독법

**(1) 차분 해독법**

- Biham과 Shamir가 개발
- 평문의 일부를 변경할 때 암호문이 어떻게 변화하는지 관찰하여 조사하는 암호 해독법
- 평문이 한비트라도 달라지면 암호문은 전혀다른 비트패턴으로 바뀌는 것을 이용하여 해독의 실마리를 찾기

**(2) 선형 해독법**

- 마츠이(Matsui)가 개발
- 평문과 암호문 비트를 몇 개 정도 XOR 해서 0이 되는 확률을 조사하는 암호 해독법
- XOR시 0이되는 확률은 보통 1/2이나, 1/2부터 크게 벗어나는 걸 찾아 해독의 실마리 찾기 → 실제로 키 스페이스가 2$^{56}$에서 $2^{47}$로 감소됨

→ 둘 다 암호해독자가 임의로 만든 평문을 암호화 할 수 있다는 가정을 한다 : `선택 평문 공격 CPA(Chosen Plaintext Attack`)

→ `AES(Advanced Encryption Standard)`를 기반으로 한 현대의 블록암호 알고리즘은 이 둘에대해 안전하도록 설계됨.

---

## Section 04 트리플 DES

### **1. 트리플** **DES란?**

`triple-DES`

전사공격으로 현실적인 시간 내에 해독되는 DES를 대신할 블록암호의 필요성에 의해 탄생

DES보다 강력하도록 DES를 3단 겹치게 한 암호 알고리즘

트리플 DES는 DES로도 사용된다 → 모든 사람이 암호체계를 한번에 바꿀 수 없는 한계 때문 (그림 4-8)

**트리플 DES의 종류**

- DES
    - 모든 키에 같은 비트열을 사용( K, K, K )
- DES-EDE2
    - 키1과 키3에 같은 키를 사용하고 키2에 다른 키를 사용( K1, K2, K1 )
    - EDE는 암호화(Encryption)→복호화(Decryption)→암호화(Encryption) 순서
- DES-EDE3
    - 키1, 키2, 키3을 모두 다른 비트열을 사용( K1, K2, K3 )

### **2. 트리플** **DES 암호화**

<img width="648" alt="Untitled 4" src="https://github.com/love-1006/TIL/assets/163835194/f064127c-f65e-423b-99a6-1a86e9eeae18">

<img width="648" alt="Untitled 5" src="https://github.com/love-1006/TIL/assets/163835194/a26e14c0-dade-43e7-9a8f-b0e5ce007b24">

트리플 DES-DES3의 키의 비트 : DES * 3 = 56 * 3 = 168비트가 된다.

암호화 → 복호화 → 암호화 루트

### **3. 트리플** **DES 복호화**

암호화의 반대, 복호화 → 암호화 → 복호화 루트

### **4. 트리플 DES의 현황**

- 현재도 은행등에서 아직 사용하지만 처리 속도는 빠르지 않다.
- 과거 DES암호와의 호환성을 위해 사용하고 새로운 용도로의 사용은 드물다.
- 우리나라에서는 3-DES를 표준으로 정하지 않았다.
    - 우리나라 국가표준은 SEED(Feistel 구조), ARIA(SPN 구조)
    
    +) 2DES는 키 스페이스가 $2^{56}$에서 $2^{57}$로밖에 증가하지 않았다.
    

---

## Section 05 AES 선정 과정

### 1. AES란?

**`AES**(Advanced Encryption Standard)`

- DES를 대신한 새로운 표준 대칭 암호 알고리즘
- AES의 후보로서 제안된 다수의 대칭 암호 알고리즘 중 **Rijndael**이란 대칭 암호 알고리즘이 2000년에 AES로서 선정되었다.

### 2. AES 선정 과정

- `NIST`(National Institute of Standard and Technology) 미국 표준화 기구에서 공모
    
    → 선정 시 미국표준규격인 연방 정보처리 표준규격이 된다. 사실상 세계 표준
    
- **`경쟁방식에 의한 표준화`**(standardization by competition)
- AES 응모 조건
    - 선정될 시 전 세계에서 아무런 제한 없이 무료로 이용
    - 128비트 블록암호방식, 다양한 키(128, 192, 256비트 등)의 길이
    - ANSI C와 Java에 의한 구현
    - 암호해독에 대한 강도의 평가
    - 암호 알고리즘 설계 규격과 프로그램 공개
    - + 암호화와 키의 설정 속도가 빠르고, 단순하며 구현하기 쉬울 것

### 3. AES 최종 후보 및 선정

1차 심사 통과 : 15개

- CAST256, Crypton, DEAL, DFC, E2, Frog, HPC, LOKI97, Magenta, MARS, RC6, Rijndael, SAFER+, Serpent, Twofish

2차 심사 통과 AES 최종 후보 (AES finalist) : 5개

---

## Section 06 Rijndael

### 1. Rijndael이란?

벨기에 석사과정 연구자 Joan Daemen과 Vincent Rijmen이 설계한 블록 암호 알고리즘

**`SPN(Substitution-Permutation Network)`** 구조

블록 길이 : 128비트

키의 비트 길이 : 128, 192, 256비트

### 2. Rijndael의 암호화와 복호화

**Rijndael의 암호화**

DES와 마찬가지로 복수의 라운드로 이루어져있다.

- SubBytes(바이트대체) → ShiftRows(행이동) → MixColumns(열 섞기) → AddRoundKey(라운드 키와 XOR) 순서로 매 라운드마다 한다.
- 약 10 ~ 14회 반복

**Rijndael의 복호화**

- AddRoundKey → MixColumns → ShiftRows → SubBytes 암호화의 역순서로 복호화된다.

페이스텔은 1회의 라운드에서 입력되는 비트 중 반만 암호화되는데에 비해 라운드 수를 줄일 수 있다.

ubBytes는 바이트마다 ShiftRows는 행마다  MixColumns는 열마다 병렬처리가 가능하다.

### 3. Rijndael의 해독

Rijndael 알고리즘의 배후에는 수학적 구조가 존재

- Rijndael의 수식을 수학적인 조작에 의해 풀 수 있다면, Rijndael을 수학적으로 해독할 수 있을 것이다
- 다만 Rijndael에 대한 유효한 공격은 현재로서는 발견되지 않았다.

### 4. 어떤 암호를 사용하면 좋은가?

- **DES**
    - 사용하지 말것, 과거 소프트웨어와의 호환성 유지를 위해 필요
- **트리플** **DES**
    - 호환성 때문에 앞으로도 당분간 사용
    - 점차 AES로 대체
- **SEED 및 ARIA**
    - 우리나라 표준
- **AES(Rijndael)**
    - 고속
    - 다양한 플랫폼
    - 현재 까지 안전
    - 사용 권장
    - AES 최종 후보 5개도 사용가능

---

## Section 07 이 장의 정리

대칭암호에 대해서 설명하고 DES, 트리플DES, AES 그 밖의 암호화 알고리즘을 소개하였다.
