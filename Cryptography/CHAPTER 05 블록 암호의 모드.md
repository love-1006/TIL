## Section 01 블록 암호 모드

### 1. 블록암호와 스트림 암호

암호알고리즘은 블록암호와 스트림암호로 나눌 수 있다.

**`블록 암호(block cipher)`**

- 어느 특정 비트 수의 집합`[블록(block)]`을 한 번에 처리하는 암호 알고리즘
- 블록의 비트 수를 **블록 길이(block length)**
    - DES나 트리플 DES의 블록 길이는 64비트
    - DES: 블록길이 64비트
    - AES: 블록길이 128비트
- 어디까지 진행되었는 지 확인하는 내부상태를 가질 필요가 없다.

**`스트림 암호(stream cipher)`**

- 데이터의 흐름(스트림)을 순차적으로 처리해 가는 암호 알고리즘
- 1비트, 8비트, 혹은 32비트 등의 단위로 암호화와 복호화
- 어디까지 진행되었는 지 확인하는 내부상태를 가지고있다.

### 2. 모드란?

- 각 블록에 암호 알고리즘을 반복해서 사용하여 긴 평문 전체를 암호화
    - 블록암호알고리즘은 고정 길이 블록을 암호화 하는 알고리즘
    - 블록암호모드는 블록암호알고리즘을 반복하여 긴 평문 전부를 암호화하기 위해 반복하는 방법`(mod)`

**블록암호 주요 모드**

- ECB 모드 : Electric CodeBook mode(전자 부호표 모드)
- CBC 모드 : Cipher Block Chaining mode(암호 블록 연쇄 모드)
- CFB 모드 : Cipher-FeedBack mode(암호 피드백 모드)
- OFB 모드 : Output-FeedBack mode(출력 피드백 모드)
- CTR 모드 : CounTeR mode(카운터 모드)

### 3. 평문 블록과 암호문 블록

<img width="624" alt="Untitled" src="https://github.com/love-1006/TIL/assets/163835194/b2b39df8-db5b-43eb-929d-3e6bb2ead1e9">

**평문블록**

- 블록암호알고리즘에서 암호화 대상이 되는 평문
- 평문 블록의 길이 = 블록 암호 알고리즘의 블록길이

**암호문블록**

- 블록암호알고리즘을 써서 평문블록을 암호화한 암호문

### 4. 적극적인 공격자 멜로리

**`맬로리**(Mallory)`: 적극적인 공격자

- 도청뿐만 아니라 적극적으로 송신자와 수신자가 주고받는 내용에 직접 개입하여 위협을 가함
- 도청, 위장, 변조, 통신방해

---

## Section 02 ECB 모드

### 1. ECB 모드란?

- `ECB모드` : 평문 블록을 암호화한 것이 그대로 암호문 블록이 되는 모드
    - 이에 따라 [평문블록 - 암호화블록이 일대일대응] 하게되어 대응표를 갖는다: `전자 코드북 모드` 라고도 함
- **`패딩**(padding)` : 마지막 평문 블록이 블록 길이에 미치지 못할 경우에 추가하여 블록 길이가 되도록 맞춰주는 비트열, 충전물

![Untitled 1](https://github.com/love-1006/TIL/assets/163835194/ade0191f-6549-4171-b1eb-addf761b9e32)

![8b46cea8-a275-40f2-a87b-7e8c235ae168](https://github.com/love-1006/TIL/assets/163835194/13e1b23e-6204-4628-83a5-5442548cd044)
→ 병렬처리가 가능

- P = D(K, C) = D(k, E(K, P) = P

### 2. ECB 모드의 특징

**장점**

- 암호화와 복호화를 병렬적으로 수행 가능
- 일부 블록만 독립적으로 암호화 가능
- 블록 오류가 다른 블록에 영향을 주지 않음

**단점**

- 가장 기밀성이 낮은 모드, 안전하지않다.
- 평문의 블록 패턴과 암호문의 블록 패턴이 동일하게 유지
    - 평문블록 1, 2의 값이 같다면 암호블록 1, 2의 값도 같게된다.
    - 암호블록교체공격에 취약
    - 암호문을 살펴보는 것만으로도 평문 속에 패턴 반복성 감지

### 3. ECB 모드에 대한 공격

블록1 : 송금자의 은행계좌번호

블록2 : 수신자의 은행계좌번호

블록3 : 송금액

이라 가정했을때 블록1, 2의 내용을 바꾸는 멜로리의 공격에 당할 수 있다.

→ **암호를 해독하지 않고도 평문을 조작 할 수 있게된다.**

---

## Section 03 CBC 모드

### 1. CBC 모드란?

`Cipher Block Chaining 모드(암호 블록 연쇄 모드)` 

- 암호문 블록을 마치 체인처럼 연결시키기 때문에 붙여진 이름
- 첫 번째 평문은 미리 정해진 초기벡터와 XOR 한다.
- 평문 블록을 암호화하기 직전의 암호문 블록과 XOR 후 암호화를 수행
- 각각의 암호문 블록은 단지 현재 평문블록 뿐만 아니라 그 이전의 평문 블록들의 영향도 받게 된다.
- C(i) = E{K, P(i) ⊕ C(i-1)}

<img width="586" alt="Untitled 2" src="https://github.com/love-1006/TIL/assets/163835194/935af070-c974-4912-a656-185c97753e5b">

![7b72aa81-9ca4-48f6-9427-e74a5f2cb7a5](https://github.com/love-1006/TIL/assets/163835194/4f3934f0-9869-4d8a-99c5-e4f3d3e19e77)

### 2. 초기화 벡터

**`초기화 벡터(initialization vector)`**

최초의 평문 블록을 암호화할 때는 1 단계 앞의 암호문 블록이 존재하지 않으므로 이를 대신할 비트열인 한 개의 블록이 존재한다.

### 3. CBC 모드의 특징

- 평문 블록은 반드시 「1 단계 앞의 암호문 블록」과 XOR을 취하고 나서 암호화
    - 따라서 만약 평문 블록1과 2의 값이 같은 경우라도 암호문 블록1과 2의 값이 같아진다고는 할 수 없고, ECB 모드가 갖고 있는 결점이 CBC 모드에는 없다.
- 암호문 블록3을 만들고 싶다면 적어도 평문 블록의 1, 2, 3까지가 갖추어져 있어야만 한다
- 암호화에서 병렬처리 불가능

- **장점**
    - 평문의 블록패턴과 암호문의 블록패턴이 동일하게 유지되지 않는다.
- **단점**
    - 블록간에 연관성이 존재하므로 병렬 처리 불가
    - 암호문 블록파손(비트변경)이 해당 암호문 블록과 다음 암호문 블록의 복호화에도 영향

- **깨진 암호문**
    
    블록비트 오류 영향
    
    - 암호 블록 오류
        - 암호 블록이 파손 : 해당 블록의 평문블록과 다음 평문 블록
        - 암호 블록에서 bit 누락 : 이후의 평문블록 전체에 영향 → 암호문을 블록으로 잘라내어 복호화하기 때문
    - 평문 블록 오류 : 이후의 모든 암호 블록 전체에 영향

<img width="596" alt="Untitled 3" src="https://github.com/love-1006/TIL/assets/163835194/aa86a1be-aa67-4e03-befe-9d7a8acf48cf">

<img width="606" alt="Untitled 4" src="https://github.com/love-1006/TIL/assets/163835194/cd7b70bf-e9be-455c-b293-79b96114dd6d">


### 4. CBC 모드에 대한 공격

- 초기화 벡터에 대한 공격
    - 맬로리가 초기화 벡터의 임의의 비트를 반전(1 이라면 0, 0 이라면 1) 시킬 수 있다면, 암호 블록1에 대응하는 평문 블록1(복호화되어 얻어지는 평문 블록)의 비트를 반전시킬 수 있다.

→ 암호문 블럭의 비트 반전시 너무 많은 변화가 일어나 금방 알아차리게 된다.

### 5. 패딩 오라클 공격

- 블록 암호의 패딩을 이용한 공격
- 패딩 내용을 조금씩 변화시켜 암호문을 여러 차례 송신
- 수신자가 올바로 복호화 하지 못할 경우 발생하는 오류를 관찰해 평문 정보를 취득
- 패딩을 사용하는 모든 모드에 적용된다.

### 6. 초기화 백터(IV) 공격

- 초기화 벡터는 난수(Random Number)로 부여
- SSL/TLS의 TLS 버전 1.0
    - 초기화 벡터를 이전 CBC 모드로 암호화한 마지막 블록을 사용
    - 문제점 발견 후 TLS 버전 1.1 부터는 초기화 벡터를 명시적으로 부여

### 7. CBC 모드 활용의 예

- SSL/TLS
    - 통신기밀성 보호
    - 예) 3DES-EDE-CBC, AES-256-CBC(길이가 256비트인 경우)

---

## Section 04 CFB 모드

### 1. CFB 모드란?

`Cipher FeedBack 모드`(**암호 피드백 모드**)의 약자

- CFB 모드에서는 1 단계 앞의 암호문 블록을 암호 알고리즘의 입력으로 사용
- 블록 암호를 써서 생성한 키를 이용하는 스트림 암호
    - 동기, 비동기식 방법 중 비동기식 방법
- 8비트 문자 전송의 경우 8비트 단위로 암호화 전송
- 평문 블록의 1비트씩 암호화 가능
- 암호화에서 병렬처리 불가능, 복호화에서는 병렬처리 가능

![4493e338-d078-403e-a0e7-d1534b048825](https://github.com/love-1006/TIL/assets/163835194/c35b01a0-8b5d-4183-832b-148a3b5f93a5)

![75621706-14fc-4371-b428-86bfa52ece8d](https://github.com/love-1006/TIL/assets/163835194/bb6c6a7e-536c-4491-b972-492898dde4b8)

스트림 암호이기 때문에, 복호화가 아닌 암호화 알고리즘을 쓴다.

→ 복호화시에는 병렬처리가 가능하다.

<img width="472" alt="Untitled 5" src="https://github.com/love-1006/TIL/assets/163835194/7d4c4021-45bf-4adf-87fb-56d76dfb60f1">

CBC모드는 (전단계 암호문 블록 ⊕ 평문 블록) → 암호화

CFB모드는 (전단계 암호문 블록을 암호화) ⊕  평문블록

- CBC모드는 암호알고리즘을 이용하여 평문 블록을 암호화
- CFB모드는 평문블록을 암호 알고리즘으로 직접 암호화 하지않음

### 2. 초기화 벡터

**초기화 벡터**(IV)

- 최초의 암호문 블록을 만들어낼 때는 1 단계 앞의 출력이 존재하지 않으므로 대신에 IV를 사용

### 3. CFB 모드와 스트림 암호

- **키 스트림**(key stream)
    - CFB 모드에서 암호 알고리즘이 생성하는 비트열
    - 키 스트림을 생성하기 위한 의사난수 생성기로서 암호 알고리즘을 이용
    - 초기화 벡터는 의사난수 생성기의「seed(종자)」에 해당
- CFB 모드는 블록 암호를 써서 생성한 키를 이용하는 스트림 암호

### 4. CFB 모드의 복호화

- CFB 모드에서 복호화를 수행할 경우, 블록 암호 알고리즘 자체는 암호화를 수행하고 있다는 것에 주의
- 키 스트림은 암호화에 의해 생성

### 5. CFB 모드에 대한 공격

- **재전송 공격**(replay attack)
    - 멜로리가 블록 일부를 복사해둔 뒤 다음날 보내지는 암호블록 일부를 이로 교환하는 공격이다.
    - 복사한 첫번째 블록은 복호화 과정에서 오류가 발생하지만 이후의 블록에서는 오류가 발생하지 않는다.
        - 통신오류인지 누군가의 공격에 의한 것인지를 판단할 수 없다.

---

## Section 05 OFB 모드

### 1. OFB 모드란?

**`OFB 모드` :** Output-FeedBack 모드(**출력 피드백 모드**)의 약자

- OFB 모드에서는 암호 알고리즘의 출력을 암호 알고리즘의 입력으로 피드백한다.
- 평문 블록은 암호 알고리즘에 의해 직접 암호화되고 있는 것은 아니다.
- 「평문 블록」과 「암호 알고리즘의 출력」을 XOR해서  「암호문 블록」을 만든다.

<img width="628" alt="Untitled 6" src="https://github.com/love-1006/TIL/assets/163835194/59c3ebdf-89ed-4357-bc1a-23bab835f6ab">

만약 암호문블록1과 2과 같다면 이후의 블록들도 같게된다.

![319d4407-062f-481e-bbc2-9dfd65eb5afd](https://github.com/love-1006/TIL/assets/163835194/49fc133c-d256-4c91-a61e-1f8efff8a99d)

### 2. 초기화 벡터

- CBC 모드나 CFB 모드와 마찬가지로 **초기화 벡터**(IV)를 사용
- 초기화 벡터는 암호화 때마다 다른 랜덤 비트열을 이용

### 3. CFB모드와 OFB 모드의 비교

- OFB 모드와 CFB 모드에서는 암호 알고리즘으로의 입력만이 다르다
- CFB는 비동기식, OFB는 동기식

<img width="648" alt="Untitled 7" src="https://github.com/love-1006/TIL/assets/163835194/1b9946e6-b763-45e7-bc3c-f54ce3a8fc8e">


---

## Section 06 CTR 모드

**`CTR 모드(**CounTeR mod)` : **CTR 모드는 1씩 증가해 가는 카운터를 암호화해서 키 스트림을 만들어 내는 스트림 암호**

- 블록을 암호화할 때마다 1씩 증가해 가는 카운터를 암호화해서 키 스트림을 만들어 내는 스트림 암호

### 1. 카운터 만드는 법

카운터 초기값 : 암호화 때마다 다른 값(nonce, 비표)을 기초로 해서 작성

![a68019f1-be58-41b2-a8c5-b0f2055e6b9a](https://github.com/love-1006/TIL/assets/163835194/78bec3dd-2f0d-450a-9257-da1161a910d4)

**암호화와 복호화**

<img width="622" alt="Untitled 8" src="https://github.com/love-1006/TIL/assets/163835194/58619d44-b147-412c-a346-b12bfa3a3a17">

![16baaa22-cb25-4c17-a29a-8a9848b162a5](https://github.com/love-1006/TIL/assets/163835194/cdbb639a-0ac9-4ed2-be49-3506c7507c02)


병렬처리가 가능하다.

### 2. OFB 모드와 CTR 모드의 비교

![OFB모드는 암호알고리즘의 출력](https://github.com/love-1006/TIL/assets/163835194/6cd2099c-e45e-4846-8daa-7d8c91dba0ba)

OFB모드는 암호알고리즘의 출력

### 3. CTR 모드의 특징

- CTR 모드의 암호화와 복호화는 완전히 같은 구조
- 프로그램으로 구현하는 것이 매우 간단
- OFB 모드와 같은 스트림 암호의 특징을 가진다.
- CTR 모드에서는 블록을 임의의 순서로 암호화・복호화 가능
- 병렬 처리가 가능한 시스템에서는 CTR 모드를 이용하여 자료를 고속으로 처리

### 4. 오류와 기밀성

- CTR 모드의 암호문 블록에서 1비트의 반전이 발생 가정
    - 복호화를 수행하면, 반전된 비트에 대응하는 **평문 블록의 1비트만이 반전** 되고, 오류는 확대되지 않는다.
- OFB 모드에서는 키 스트림의 1블록을 암호화한 결과가, 암호화 전의 결과와 우연히 같아졌다고 하면 그 이후 키 스트림은 완전히 같은 값의 반복이 된다.
    - CTR 모드에서는 그런 걱정은 없다.

- GCM(Galois/Counter Mode)
    - CTR 모드에 인증 기능을 추가한 모드
    - CTR 모드로 암호문과 인증자를 생성
    - 암호문 위조를 탐지할 수 있음

---

## Section 07 이 장의 정리

<img width="1231" alt="%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-04-21_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_4 57 14" src="https://github.com/love-1006/TIL/assets/163835194/4ca834e5-6cd0-4553-a44d-cb11e7e55c31">

- ECB 모드
    1. 평문블록1을 암호화
    2. 평문블록2를 암호화
    - 양쪽 다 병렬처리 가능
- CBC 모드
    1. [           IV ⊕ 평문블록1           ] → 암호화
    2. [이전 암호화 블록 ⊕ 평문블록2] → 암호화
    - 복호화만 병렬처리 가능
- CFB 모드
    1. [          IV 암호화 ⊕ 평문블록1           ]
    2. [이전 암호화 블록 암호화 ⊕ 평문블록2]
    - 복호화만 병렬처리 가능
- OFB 모드
    1. [          IV 암호화 ⊕ 평문블록1           ]
    2. [   IV 암호화를 암호화 ⊕ 평문블록2    ]
    - 양쪽 다 병렬처리 불가능
- CTR 모드
    1. [CTR     을 암호화 한 것 ⊕ 평문블록]
    2. [CTR+1 을 암호화 한 것 ⊕ 평문블록]
    - 양쪽 다 병렬처리 가능

